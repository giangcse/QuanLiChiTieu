# -*- coding: utf-8 -*-

import logging
import re
import pandas as pd
from datetime import datetime
from telegram import Update, ForceReply
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# Th∆∞ vi·ªán cho Machine Learning
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
import numpy as np

# --- C·∫§U H√åNH ---
TOKEN = 'YOUR_TELEGRAM_API_TOKEN' # THAY TH·∫æ B·∫∞NG TOKEN C·ª¶A B·∫†N
DATA_FILE = 'thu_chi_data.csv' # ƒê·ªïi t√™n file ƒë·ªÉ l∆∞u c·∫£ thu v√† chi

# B·∫≠t logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- B·ªò PH·∫¨N M√ÅY H·ªåC ---
# Hai m√¥ h√¨nh ri√™ng bi·ªát cho Chi ti√™u v√† Thu nh·∫≠p
expense_model = None
income_model = None

def train_models():
    """Hu·∫•n luy·ªán ƒë·ªìng th·ªùi c·∫£ hai m√¥ h√¨nh ph√¢n lo·∫°i."""
    global expense_model, income_model
    logger.info("B·∫Øt ƒë·∫ßu hu·∫•n luy·ªán c√°c m√¥ h√¨nh...")

    # --- D·ªØ li·ªáu hu·∫•n luy·ªán cho CHI TI√äU ---
    expense_data = [
        ("c∆°m s∆∞·ªùn tr∆∞a", "ƒÇn u·ªëng"), ("mua ly tr√† s·ªØa", "ƒÇn u·ªëng"), ("c√† ph√™ v·ªõi b·∫°n", "ƒÇn u·ªëng"),
        ("ƒë·ªï xƒÉng xe m√°y", "ƒêi l·∫°i"), ("v√© xe bus th√°ng", "ƒêi l·∫°i"), ("ti·ªÅn grab ƒëi l√†m", "ƒêi l·∫°i"),
        ("mua √°o s∆° mi", "Mua s·∫Øm"), ("ƒë·∫∑t h√†ng shopee", "Mua s·∫Øm"), ("mua m·ªôt ƒë√¥i gi√†y m·ªõi", "Mua s·∫Øm"),
        ("thanh to√°n ti·ªÅn ƒëi·ªán", "H√≥a ƒë∆°n"), ("ƒë√≥ng ti·ªÅn net FPT", "H√≥a ƒë∆°n"), ("ti·ªÅn nh√† th√°ng 8", "H√≥a ƒë∆°n"),
        ("v√© xem phim cgv", "Gi·∫£i tr√≠"), ("mua thu·ªëc c·∫£m", "S·ª©c kh·ªèe"),
    ]
    expense_descriptions = [item[0] for item in expense_data]
    expense_categories = [item[1] for item in expense_data]
    
    expense_model = Pipeline([
        ('tfidf', TfidfVectorizer()), ('clf', MultinomialNB()),
    ])
    expense_model.fit(expense_descriptions, expense_categories)
    logger.info("Hu·∫•n luy·ªán m√¥ h√¨nh CHI TI√äU th√†nh c√¥ng!")

    # --- D·ªØ li·ªáu hu·∫•n luy·ªán cho THU NH·∫¨P ---
    income_data = [
        ("l∆∞∆°ng th√°ng 8", "L∆∞∆°ng"), ("nh·∫≠n l∆∞∆°ng c√¥ng ty", "L∆∞∆°ng"),
        ("th∆∞·ªüng d·ª± √°n", "Th∆∞·ªüng"), ("ƒë∆∞·ª£c s·∫øp th∆∞·ªüng", "Th∆∞·ªüng"),
        ("ti·ªÅn cho thu√™ xe", "Thu nh·∫≠p ph·ª•"), ("cho thu√™ nh√†", "Thu nh·∫≠p ph·ª•"),
        ("b√°n ƒë·ªì c≈© online", "Thu nh·∫≠p ph·ª•"), ("l√£i ng√¢n h√†ng", "ƒê·∫ßu t∆∞"),
    ]
    income_descriptions = [item[0] for item in income_data]
    income_categories = [item[1] for item in income_data]

    income_model = Pipeline([
        ('tfidf', TfidfVectorizer()), ('clf', MultinomialNB()),
    ])
    income_model.fit(income_descriptions, income_categories)
    logger.info("Hu·∫•n luy·ªán m√¥ h√¨nh THU NH·∫¨P th√†nh c√¥ng!")

def classify_transaction(description: str, transaction_type: str) -> str:
    """Ph√¢n lo·∫°i giao d·ªãch d·ª±a tr√™n lo·∫°i (thu/chi)."""
    if transaction_type == 'chi' and expense_model:
        return expense_model.predict([description])[0]
    elif transaction_type == 'thu' and income_model:
        return income_model.predict([description])[0]
    return "Kh√°c"

# --- C√ÅC H√ÄM X·ª¨ L√ù L·ªÜNH ---

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    await update.message.reply_html(
        f"Xin ch√†o {user.mention_html()}!\n\n"
        f"T√¥i l√† –±–æ—Ç qu·∫£n l√Ω Thu - Chi c√° nh√¢n.\n\n"
        f"‚úçÔ∏è **ƒê·ªÉ ghi m·ªôt giao d·ªãch, ch·ªâ c·∫ßn g√µ s·ªë ti·ªÅn v√† n·ªôi dung.**\n"
        f"B·∫°n c√≥ th·ªÉ ƒë·∫∑t s·ªë ti·ªÅn ·ªü tr∆∞·ªõc ho·∫∑c sau n·ªôi dung.\n\n"
        f"<b>V√≠ d·ª• chi ti√™u:</b>\n"
        f"<code>50000 ƒÉn tr∆∞a</code> ho·∫∑c <code>ƒÉn tr∆∞a 50000</code>\n\n"
        f"<b>V√≠ d·ª• thu nh·∫≠p (th√™m 'thu' ho·∫∑c '+'):</b>\n"
        f"<code>thu 10000000 l∆∞∆°ng</code> ho·∫∑c <code>l∆∞∆°ng 10000000 +</code>\n\n"
        f"<i>N·∫øu kh√¥ng c√≥ 'thu' ho·∫∑c '+', t√¥i s·∫Ω m·∫∑c ƒë·ªãnh l√† CHI TI√äU.</i>\n\n"
        f"G√µ /help ƒë·ªÉ xem t·∫•t c·∫£ c√°c l·ªánh.",
        reply_markup=ForceReply(selective=True),
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "üí° **C√°c l·ªánh b·∫°n c√≥ th·ªÉ d√πng:**\n\n"
        "/start - B·∫Øt ƒë·∫ßu v√† xem h∆∞·ªõng d·∫´n\n"
        "/help - Xem l·∫°i tin nh·∫Øn n√†y\n"
        "/tuan - Th·ªëng k√™ Thu-Chi tu·∫ßn n√†y\n"
        "/thang - Th·ªëng k√™ Thu-Chi th√°ng n√†y"
    )

async def handle_transaction_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    X·ª≠ l√Ω tin nh·∫Øn giao d·ªãch m·ªôt c√°ch linh ho·∫°t.
    T·ª± ƒë·ªông ph√°t hi·ªán s·ªë ti·ªÅn v√† n·ªôi dung.
    """
    text = update.message.text.lower()
    user_id = update.message.from_user.id
    
    # B∆∞·ªõc 1: T√¨m t·∫•t c·∫£ c√°c s·ªë trong tin nh·∫Øn
    numbers = re.findall(r'\d+', text)

    # B∆∞·ªõc 2: Ki·ªÉm tra n·∫øu kh√¥ng c√≥ s·ªë ti·ªÅn
    if not numbers:
        await update.message.reply_text(
            '‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y s·ªë ti·ªÅn trong tin nh·∫Øn c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i.'
        )
        return
    
    # B∆∞·ªõc 3: X√°c ƒë·ªãnh s·ªë ti·ªÅn (gi·∫£ ƒë·ªãnh l√† s·ªë l·ªõn nh·∫•t)
    amount = max([int(n) for n in numbers])
    
    # B∆∞·ªõc 4: T√°ch n·ªôi dung v√† c√°c t·ª´ kh√≥a
    # X√≥a t·∫•t c·∫£ c√°c s·ªë ƒë√£ t√¨m th·∫•y kh·ªèi vƒÉn b·∫£n g·ªëc ƒë·ªÉ c√≥ ƒë∆∞·ª£c n·ªôi dung
    description_full = text
    for num_str in numbers:
        # S·ª≠ d·ª•ng regex v·ªõi \b (word boundary) ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ x√≥a c√°c t·ª´ l√† s·ªë
        description_full = re.sub(r'\b' + num_str + r'\b', '', description_full).strip()
    
    # B∆∞·ªõc 5: X√°c ƒë·ªãnh lo·∫°i giao d·ªãch (thu/chi)
    transaction_type = 'chi'  # M·∫∑c ƒë·ªãnh l√† chi ti√™u
    icon = 'üí∏'
    
    # Ki·ªÉm tra c√°c t·ª´ kh√≥a c·ªßa thu nh·∫≠p trong n·ªôi dung
    if any(keyword in description_full.split() for keyword in ['thu', '+']):
        transaction_type = 'thu'
        icon = 'üí∞'
    
    # B∆∞·ªõc 6: L√†m s·∫°ch n·ªôi dung cu·ªëi c√πng
    # X√≥a c√°c t·ª´ kh√≥a (thu, chi, +, -) kh·ªèi n·ªôi dung
    keywords_to_remove = ['thu', 'chi', '+', '-']
    description_words = [word for word in description_full.split() if word not in keywords_to_remove]
    description = ' '.join(description_words).strip()

    if not description:
        await update.message.reply_text(
            '‚ö†Ô∏è Giao d·ªãch c·ªßa b·∫°n c·∫ßn c√≥ n·ªôi dung m√¥ t·∫£.\n'
            'V√≠ d·ª•: <code>ƒÇn s√°ng 20000</code>',
            parse_mode='HTML'
        )
        return

    # B∆∞·ªõc 7: Ph√¢n lo·∫°i v√† l∆∞u tr·ªØ (logic kh√¥ng ƒë·ªïi)
    category = classify_transaction(description, transaction_type)
    date = datetime.now()
    save_transaction(user_id, date, amount, category, description, transaction_type)

    await update.message.reply_text(
        f'{icon} ƒê√£ ghi nh·∫≠n m·ªôt kho·∫£n <b>{transaction_type.upper()}</b>\n'
        f'<b>S·ªë ti·ªÅn:</b> {amount:,.0f} VNƒê\n'
        f'<b>N·ªôi dung:</b> {description}\n'
        f'<b>Danh m·ª•c:</b> {category}',
        parse_mode='HTML'
    )

async def weekly_stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Th·ªëng k√™ thu chi trong tu·∫ßn hi·ªán t·∫°i."""
    now = datetime.now()
    await generate_full_report(update, context, "week", f"Tu·∫ßn {now.isocalendar().week}, {now.year}")

async def monthly_stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Th·ªëng k√™ thu chi trong th√°ng hi·ªán t·∫°i."""
    now = datetime.now()
    await generate_full_report(update, context, "month", f"Th√°ng {now.month}/{now.year}")

# --- C√ÅC H√ÄM TI·ªÜN √çCH ---

def save_transaction(user_id, date, amount, category, description, transaction_type):
    """L∆∞u giao d·ªãch (thu ho·∫∑c chi) v√†o file CSV."""
    try:
        df = pd.read_csv(DATA_FILE)
    except FileNotFoundError:
        df = pd.DataFrame(columns=['user_id', 'date', 'type', 'amount', 'category', 'description'])

    new_row = pd.DataFrame([{
        'user_id': user_id,
        'date': date.strftime('%Y-%m-%d %H:%M:%S'),
        'type': transaction_type,
        'amount': amount,
        'category': category,
        'description': description
    }])
    df = pd.concat([df, new_row], ignore_index=True)
    df.to_csv(DATA_FILE, index=False)

async def generate_full_report(update: Update, context: ContextTypes.DEFAULT_TYPE, period_type: str, period_name: str):
    """T·∫°o b√°o c√°o Thu-Chi t·ªïng h·ª£p."""
    user_id = update.message.from_user.id
    try:
        df = pd.read_csv(DATA_FILE)
        df['date'] = pd.to_datetime(df['date'])
    except FileNotFoundError:
        await update.message.reply_text('B·∫°n ch∆∞a c√≥ d·ªØ li·ªáu n√†o ƒë·ªÉ th·ªëng k√™.')
        return

    now = datetime.now()
    # L·ªçc d·ªØ li·ªáu theo th·ªùi gian (tu·∫ßn ho·∫∑c th√°ng)
    if period_type == "week":
        period_filter = (df['date'].dt.isocalendar().week == now.isocalendar().week) & (df['date'].dt.year == now.year)
    else: # month
        period_filter = (df['date'].dt.month == now.month) & (df['date'].dt.year == now.year)

    user_df = df[(df['user_id'] == user_id) & period_filter]

    if user_df.empty:
        await update.message.reply_text(f'B·∫°n kh√¥ng c√≥ giao d·ªãch n√†o trong {period_name.lower()}.')
        return

    # T√°ch th√†nh 2 b·∫£ng thu v√† chi
    income_df = user_df[user_df['type'] == 'thu']
    expense_df = user_df[user_df['type'] == 'chi']

    total_income = income_df['amount'].sum()
    total_expense = expense_df['amount'].sum()
    balance = total_income - total_expense

    # X√¢y d·ª±ng chu·ªói ph·∫£n h·ªìi
    response = f"üìä <b>B√°o c√°o t√†i ch√≠nh {period_name}</b>\n\n"
    response += f"üü¢ <b>T·ªïng Thu:</b> {total_income:,.0f} VNƒê\n"
    response += f"üî¥ <b>T·ªïng Chi:</b> {total_expense:,.0f} VNƒê\n"
    response += f"<b>‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ</b>\n"
    response += f"üìà <b>S·ªë d∆∞: {balance:,.0f} VNƒê</b>\n\n"

    # Th·ªëng k√™ chi ti·∫øt thu nh·∫≠p
    if not income_df.empty:
        response += "<b>--- Chi ti·∫øt c√°c kho·∫£n THU ---</b>\n"
        income_stats = income_df.groupby('category')['amount'].sum().sort_values(ascending=False)
        for category, amount in income_stats.items():
            response += f"  - {category}: {amount:,.0f} VNƒê\n"
        response += "\n"

    # Th·ªëng k√™ chi ti·∫øt chi ti√™u
    if not expense_df.empty:
        response += "<b>--- Chi ti·∫øt c√°c kho·∫£n CHI ---</b>\n"
        expense_stats = expense_df.groupby('category')['amount'].sum().sort_values(ascending=False)
        for category, amount in expense_stats.items():
            response += f"  - {category}: {amount:,.0f} VNƒê\n"

    await update.message.reply_text(response, parse_mode='HTML')

# --- H√ÄM MAIN ƒê·ªÇ KH·ªûI ƒê·ªòNG BOT ---

def main() -> None:
    """Kh·ªüi ƒë·ªông bot v√† l·∫Øng nghe c√°c y√™u c·∫ßu."""
    # Hu·∫•n luy·ªán c·∫£ 2 m√¥ h√¨nh khi bot kh·ªüi ƒë·ªông
    train_models()

    application = Application.builder().token(TOKEN).build()

    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("tuan", weekly_stats_command))
    application.add_handler(CommandHandler("thang", monthly_stats_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_transaction_message))

    print("Bot Qu·∫£n l√Ω Thu-Chi (phi√™n b·∫£n th√¥ng minh) ƒëang ch·∫°y...")
    application.run_polling()
    print("Bot ƒë√£ d·ª´ng.")

if __name__ == '__main__':
    main()
